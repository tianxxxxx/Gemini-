<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AR 拟真手势交互系统</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Noto Sans SC', sans-serif; }
        
        /* 核心布局：视频在底层，Canvas在上层 */
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* 1. 摄像头背景 (镜像显示) */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; /* 填满屏幕 */
            transform: scaleX(-1); /* 镜像翻转，符合镜子直觉 */
            z-index: 0;
        }

        /* 2. 左侧控制面板 - 亚克力风格 */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 300px;
            /* 亚克力毛玻璃效果 */
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
            z-index: 100;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; color: #fff; text-shadow: 0 0 5px rgba(0,0,0,0.5); border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px;}
        
        .status-row { display: flex; justify-content: space-between; font-size: 12px; color: #eee; margin-bottom: 15px; }

        /* 输入框与按钮 */
        input { 
            width: 100%; padding: 10px; margin-bottom: 10px; 
            border: 1px solid rgba(255,255,255,0.3); border-radius: 8px;
            background: rgba(0,0,0,0.2); color: #fff; outline: none; box-sizing: border-box;
        }
        input:focus { background: rgba(0,0,0,0.4); border-color: #fff; }

        button {
            width: 100%; padding: 12px; border: none; border-radius: 8px;
            background: rgba(255, 255, 255, 0.9); color: #333; 
            font-weight: bold; cursor: pointer; transition: all 0.2s;
        }
        button:hover { background: #fff; transform: scale(1.02); }
        button.recording { background: #ff4444; color: white; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255,68,68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255,68,68, 0); } 100% { box-shadow: 0 0 0 0 rgba(255,68,68, 0); } }

        /* 相似度条 */
        .meter-box { margin-top: 15px; background: rgba(0,0,0,0.3); height: 8px; border-radius: 4px; overflow: hidden; }
        .meter-bar { height: 100%; width: 0%; background: #00ff88; transition: width 0.2s; }
        .meter-text { font-size: 10px; text-align: right; margin-top: 2px; color: #ccc;}

        /* 列表 */
        .list-wrap { margin-top: 20px; max-height: 200px; overflow-y: auto; border-top: 1px solid rgba(255,255,255,0.1); padding-top:10px;}
        .gesture-item { display: flex; justify-content: space-between; padding: 8px 0; font-size: 13px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .del-btn { color: #ff9999; cursor: pointer; padding: 0 5px; }

        /* 3. 屏幕中央全息显示 - 亚克力面板风格 */
        #hologram-card {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            /* 亚克力板 */
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            padding: 30px 60px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.2);
            
            /* 文字样式 */
            font-size: 60px; font-weight: 900; color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            text-align: center; white-space: nowrap;
            
            /* 动画 */
            opacity: 0; pointer-events: none; z-index: 200;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #hologram-card.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        /* 倒计时层 */
        #countdown-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center; z-index: 300;
        }
        #countdown-num { font-size: 150px; font-weight: bold; color: #fff; text-shadow: 0 0 30px rgba(0,0,0,0.5); }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    
    <div id="countdown-layer"><div id="countdown-num">3</div></div>
    
    <div id="ui-layer">
        <h2>AR 手势控制中心</h2>
        <div class="status-row">
            <span>状态: <span id="sys-status" style="color:#00ff88">运行中</span></span>
            <span>识别到: <span id="hand-count">0</span> 只手</span>
        </div>

        <input type="text" id="gesture-name" placeholder="在此输入动作名称...">
        <button id="rec-btn" onclick="startCountdownLogic()">开始录制 (倒计时)</button>
        
        <div class="meter-box"><div class="meter-bar" id="prob-bar"></div></div>
        <div class="meter-text">动作匹配度: <span id="prob-val">0%</span></div>

        <div class="list-wrap" id="gesture-list">
            </div>
        
        <div style="margin-top:15px; display:flex; gap:10px;">
            <button onclick="saveDB()" style="font-size:12px; background:rgba(255,255,255,0.2); color:#fff;">保存配置</button>
            <button onclick="clearDB()" style="font-size:12px; background:rgba(255,255,255,0.2); color:#ff9999;">清空</button>
        </div>
    </div>

    <div id="hologram-card">测试文字</div>
</div>

<script>
    // ============================================
    // 1. Three.js 场景 (透明背景 + AR对齐)
    // ============================================
    const scene = new THREE.Scene();
    
    // 关键：相机参数要微调，配合 AR 感觉
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20); // 距离适中

    // 关键：渲染器设为透明，才能看到底下的视频
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0); // 完全透明
    document.getElementById('container').appendChild(renderer.domElement);

    // 灯光系统 - 模拟自然光照在手上
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffeedd, 0.8);
    dirLight.position.set(5, 10, 10);
    scene.add(dirLight);
    const fillLight = new THREE.PointLight(0xccddff, 0.5);
    fillLight.position.set(-5, 0, 5);
    scene.add(fillLight);

    // ============================================
    // 2. 拟真类人手部模型 (Humanoid Mesh)
    // ============================================
    // 我们不使用 Stick，而是使用粗壮的 Capsule/Cylinder 连接，
    // 并使用 MeshPhysicalMaterial 模拟皮肤质感
    
    // 骨骼连接定义
    const BONES = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17],[0,5]];

    class HumanoidHand {
        constructor() {
            this.group = new THREE.Group();
            scene.add(this.group);
            this.segments = [];

            // 皮肤材质
            const skinMat = new THREE.MeshPhysicalMaterial({
                color: 0xffdbac, // 浅肤色
                roughness: 0.3,
                metalness: 0.1,
                reflectivity: 0.5,
                clearcoat: 0.1,
                transparent: true,
                opacity: 0.95
            });

            // 初始化骨骼段 (用 Mesh 模拟肌肉)
            BONES.forEach(pair => {
                // 使用圆柱体模拟手指节
                const geo = new THREE.CylinderGeometry(0.55, 0.5, 1, 16);
                geo.translate(0, 0.5, 0); // 调整中心点到底部
                geo.rotateX(Math.PI/2);
                
                const mesh = new THREE.Mesh(geo, skinMat);
                mesh.castShadow = true;
                
                this.segments.push({ mesh: mesh, start: pair[0], end: pair[1] });
                this.group.add(mesh);
            });
            
            // 关节处加球体，使连接平滑
            this.joints = [];
            for(let i=0; i<21; i++) {
                const geo = new THREE.SphereGeometry(0.55, 16, 16);
                const mesh = new THREE.Mesh(geo, skinMat);
                this.joints.push(mesh);
                this.group.add(mesh);
            }
        }

        update(landmarks) {
            if (!landmarks) {
                this.group.visible = false;
                return;
            }
            this.group.visible = true;

            const worldPos = [];
            landmarks.forEach((lm, i) => {
                // 坐标映射：必须与视频画面对齐
                // MediaPipe 输出 0-1。
                // 3D 场景中，我们大致映射到 x: -15~15, y: -10~10
                
                const x = (0.5 - lm.x) * 32; 
                const y = (0.5 - lm.y) * 24; 
                // Z 轴缩放，体现远近
                const z = lm.z * -25; 
                
                const v = new THREE.Vector3(x, y, z);
                worldPos.push(v);
                
                // 更新关节球
                this.joints[i].position.copy(v);
            });

            // 更新骨骼段
            this.segments.forEach(seg => {
                const p1 = worldPos[seg.start];
                const p2 = worldPos[seg.end];
                
                seg.mesh.position.copy(p1);
                seg.mesh.lookAt(p2);
                
                // 缩放长度以连接两点
                const dist = p1.distanceTo(p2);
                seg.mesh.scale.set(1, 1, dist);
            });
        }
    }

    const leftHand = new HumanoidHand();
    const rightHand = new HumanoidHand();


    // ============================================
    // 3. 增强版动作识别 (解决无反应问题)
    // ============================================

    let gestureDB = JSON.parse(localStorage.getItem('arGestures') || '[]');
    let liveBuffer = [];
    const MAX_BUFFER = 60; // 存2秒数据

    // 特征提取：使用“相对手腕的归一化坐标”
    function getFeatures(landmarks) {
        if(!landmarks) return Array(45).fill(0); // 15 points * 3 dims
        
        const wrist = landmarks[0];
        // 尺度因子：手掌大小 (手腕到中指根部)
        let scale = Math.sqrt(
            (landmarks[9].x - wrist.x)**2 + 
            (landmarks[9].y - wrist.y)**2 + 
            (landmarks[9].z - wrist.z)**2
        ) || 0.1;

        const feats = [];
        // 选取关键特征点 (指尖 + 指根 + 拇指关节)
        // 减少点数以减少噪音
        const indices = [4, 8, 12, 16, 20, 5, 9, 13, 17]; 
        
        indices.forEach(i => {
            feats.push((landmarks[i].x - wrist.x) / scale);
            feats.push((landmarks[i].y - wrist.y) / scale);
            feats.push((landmarks[i].z - wrist.z) / scale); 
        });
        return feats;
    }

    // DTW 距离算法
    function calcDTW(seq1, seq2) {
        const n = seq1.length;
        const m = seq2.length;
        // 长度差异过大直接放弃
        if (Math.abs(n - m) > Math.min(n, m) * 0.5) return Infinity;

        const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
        dtw[0][0] = 0;

        for (let i = 1; i <= n; i++) {
            // 限制搜索窗口，优化性能
            const window = Math.max(5, Math.abs(n-m)+5);
            const start = Math.max(1, i - window);
            const end = Math.min(m, i + window);
            
            for (let j = start; j <= end; j++) {
                let dist = 0;
                const v1 = seq1[i-1];
                const v2 = seq2[j-1];
                for(let k=0; k<v1.length; k++) dist += (v1[k]-v2[k])**2;
                
                dtw[i][j] = dist + Math.min(dtw[i-1][j], dtw[i][j-1], dtw[i-1][j-1]);
            }
        }
        return dtw[n][m] / (n + m);
    }

    // 识别核心逻辑
    let cooldown = 0;
    
    function detectGesture() {
        if(cooldown > 0) { cooldown--; return; }
        if(gestureDB.length === 0 || liveBuffer.length < 15) return;

        let bestScore = Infinity;
        let bestName = "";

        gestureDB.forEach(g => {
            const targetLen = g.data.length;
            // 滑动窗口 + 多尺度匹配 (解决速度不一致导致不识别的问题)
            // 尝试匹配 liveBuffer 尾部的不同长度：0.8倍长, 1.0倍长, 1.2倍长
            const scales = [0.8, 1.0, 1.2];
            
            scales.forEach(scale => {
                const tryLen = Math.floor(targetLen * scale);
                if (liveBuffer.length < tryLen) return;
                
                const sample = liveBuffer.slice(liveBuffer.length - tryLen);
                const score = calcDTW(sample, g.data);
                
                if(score < bestScore) {
                    bestScore = score;
                    bestName = g.name;
                }
            });
        });

        // 可视化匹配度 (将分数转化为百分比)
        // 阈值设为 1.5 (非常宽松) 以解决“无反应”问题
        const THRESHOLD = 1.5; 
        const confidence = Math.max(0, 1 - (bestScore / 3.0)) * 100;
        
        document.getElementById('prob-bar').style.width = confidence + "%";
        document.getElementById('prob-val').textContent = Math.round(confidence) + "%";

        if(bestScore < THRESHOLD) {
            showHologram(bestName);
            // 识别成功后，清空 buffer，防止连续触发，并设置冷却
            liveBuffer = []; 
            cooldown = 40; // 约1.5秒冷却
        }
    }

    // ============================================
    // 4. UI 交互逻辑 (录制、倒计时、显示)
    // ============================================

    let isRecording = false;
    let recBuffer = [];
    const recBtn = document.getElementById('rec-btn');
    const countdownLayer = document.getElementById('countdown-layer');
    const countdownNum = document.getElementById('countdown-num');

    window.startCountdownLogic = function() {
        if(isRecording) {
            stopRecording();
            return;
        }
        const name = document.getElementById('gesture-name').value;
        if(!name) return alert("请先输入动作名称！");

        countdownLayer.style.display = 'flex';
        let n = 3;
        countdownNum.textContent = n;
        
        const timer = setInterval(() => {
            n--;
            if(n > 0) countdownNum.textContent = n;
            else if(n === 0) countdownNum.textContent = "开始!";
            else {
                clearInterval(timer);
                countdownLayer.style.display = 'none';
                startRecording();
            }
        }, 1000);
    };

    function startRecording() {
        isRecording = true;
        recBuffer = [];
        recBtn.textContent = "停止录制 (点击结束)";
        recBtn.classList.add('recording');
        document.getElementById('sys-status').textContent = "正在录制...";
        document.getElementById('sys-status').style.color = "#ff4444";
    }

    function stopRecording() {
        isRecording = false;
        recBtn.textContent = "开始录制 (倒计时)";
        recBtn.classList.remove('recording');
        document.getElementById('sys-status').textContent = "运行中";
        document.getElementById('sys-status').style.color = "#00ff88";

        if(recBuffer.length < 10) return alert("动作太短，请重试");
        
        const name = document.getElementById('gesture-name').value;
        gestureDB.push({ name: name, data: recBuffer });
        updateList();
        saveDB();
        showHologram(`已保存: ${name}`);
    }

    let holoTimeout;
    function showHologram(text) {
        const el = document.getElementById('hologram-card');
        el.textContent = text;
        el.classList.add('active');
        if(holoTimeout) clearTimeout(holoTimeout);
        holoTimeout = setTimeout(() => {
            el.classList.remove('active');
        }, 2000);
    }

    function updateList() {
        const div = document.getElementById('gesture-list');
        div.innerHTML = '';
        gestureDB.forEach((g, i) => {
            const item = document.createElement('div');
            item.className = 'gesture-item';
            item.innerHTML = `<span>${g.name}</span> <span class="del-btn" onclick="delGesture(${i})">×</span>`;
            div.appendChild(item);
        });
    }

    window.delGesture = (i) => { gestureDB.splice(i, 1); updateList(); saveDB(); };
    window.saveDB = () => localStorage.setItem('arGestures', JSON.stringify(gestureDB));
    window.clearDB = () => { if(confirm("确定清空?")) { gestureDB=[]; updateList(); saveDB(); }};
    
    // 初始化列表
    updateList();


    // ============================================
    // 5. MediaPipe 主循环
    // ============================================

    const videoElem = document.getElementById('input-video');
    
    function onResults(results) {
        let lLandmarks = null;
        let rLandmarks = null;
        let count = 0;

        // 隐藏手部
        leftHand.update(null);
        rightHand.update(null);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            count = results.multiHandLandmarks.length;
            results.multiHandLandmarks.forEach((lm, i) => {
                const label = results.multiHandedness[i].label;
                // 镜像后：Label Left 对应 屏幕右侧的手 (视觉上的右手)
                if (label === 'Right') {
                    rightHand.update(lm);
                    rLandmarks = lm;
                } else {
                    leftHand.update(lm);
                    lLandmarks = lm;
                }
            });
        }
        document.getElementById('hand-count').textContent = count;

        // 特征处理
        const featL = getFeatures(lLandmarks);
        const featR = getFeatures(rLandmarks);
        const combinedFeats = featL.concat(featR); // 拼接双手特征

        if (isRecording) {
            recBuffer.push(combinedFeats);
        } else {
            liveBuffer.push(combinedFeats);
            if(liveBuffer.length > MAX_BUFFER) liveBuffer.shift();
            detectGesture();
        }

        renderer.render(scene, camera);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5, // 降低一点以防丢失
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElem, {
        onFrame: async () => { await hands.send({image: videoElem}); },
        width: 1280, height: 720
    });
    cameraUtils.start();

    // 窗口自适应
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
