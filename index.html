<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AR 自定义动作识别 (基准重构版)</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@500;900&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Noto Sans SC', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* 1. 视频层 (实景背景) */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); z-index: 0;
        }

        /* 2. 左侧控制面板 (亚克力) */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 320px;
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px; padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            color: #fff; z-index: 100;
        }

        h2 { margin: 0 0 15px 0; font-size: 16px; color: #00ffcc; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; letter-spacing: 1px;}
        
        .status-block { display: flex; justify-content: space-between; font-size: 12px; color: #ccc; margin-bottom: 15px; }

        input { 
            width: 100%; padding: 12px; margin-bottom: 10px; 
            border: 1px solid #555; border-radius: 6px;
            background: rgba(0,0,0,0.5); color: #fff; outline: none; box-sizing: border-box; font-weight: bold;
        }
        input:focus { border-color: #00ffcc; background: rgba(0,0,0,0.8); }

        button {
            width: 100%; padding: 12px; border: none; border-radius: 6px;
            background: #eee; color: #111; 
            font-weight: 900; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
        }
        button:hover { background: #fff; transform: scale(1.02); }
        button.recording { background: #ff4d4d; color: white; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* 匹配度条 */
        .meter-wrap { margin-top: 15px; background: rgba(0,0,0,0.5); height: 6px; border-radius: 3px; overflow: hidden; }
        .meter-fill { height: 100%; width: 0%; background: #00ffcc; transition: width 0.1s; }
        .meter-info { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-top: 4px; }

        /* 列表 */
        .list-box { margin-top: 20px; max-height: 250px; overflow-y: auto; border-top: 1px solid rgba(255,255,255,0.1); padding-top:10px;}
        .list-item { 
            display: flex; justify-content: space-between; padding: 10px; 
            background: rgba(255,255,255,0.05); margin-bottom: 5px; border-radius: 4px; font-size: 13px; align-items: center;
        }
        .del-icon { color: #ff6666; cursor: pointer; padding: 5px; font-weight: bold;}

        /* 3. 全息文字显示 */
        #hologram-display {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 90px;
            color: #fff; text-shadow: 0 0 20px #00ffcc, 0 0 50px #00ffcc;
            pointer-events: none; opacity: 0; z-index: 200; white-space: nowrap;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #hologram-display.active { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }

        /* 倒计时层 */
        #countdown-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
            display: none; justify-content: center; align-items: center; z-index: 300;
        }
        #countdown-text { font-size: 120px; font-weight: 900; color: #00ffcc; text-shadow: 0 0 40px #00ffcc; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    <div id="countdown-overlay"><div id="countdown-text">3</div></div>
    
    <div id="ui-layer">
        <h2>自定义动作录制系统</h2>
        <div class="status-block">
            <span>系统: <span id="sys-status" style="color:#00ffcc">就绪</span></span>
            <span>当前: <span id="hand-status">无手部</span></span>
        </div>

        <input type="text" id="action-name" placeholder="输入你想显示的文字...">
        <button id="rec-btn" onclick="triggerRecordFlow()">开始录制 (倒计时)</button>
        
        <div class="meter-wrap"><div class="meter-fill" id="match-bar"></div></div>
        <div class="meter-info">
            <span>差异值(Diff): <span id="diff-val">--</span></span>
            <span>匹配度: <span id="conf-val">0%</span></span>
        </div>

        <div class="list-box" id="action-list"></div>
        
        <div style="margin-top:15px; font-size:10px; color:#666; text-align:center;">
            算法: 相对坐标 DTW | 存储: 本地浏览器
        </div>
    </div>

    <div id="hologram-display">HOLOGRAM</div>
</div>

<script>
    // ============================================
    // 1. 3D 场景与拟真手 (保持高颜值)
    // ============================================
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0);
    document.getElementById('container').appendChild(renderer.domElement);

    // 氛围光
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const spotLight = new THREE.SpotLight(0x00ffcc, 1);
    spotLight.position.set(5, 10, 10);
    scene.add(spotLight);

    // 手部模型类
    const BONES = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17],[0,5]];
    
    class RealHand {
        constructor() {
            this.group = new THREE.Group();
            scene.add(this.group);
            this.meshes = []; // 存储所有圆柱体和球体
            
            // 材质：像皮肤一样的半透明材质
            const mat = new THREE.MeshPhysicalMaterial({
                color: 0xffccaa, roughness: 0.3, metalness: 0.0,
                transmission: 0.1, opacity: 0.95, transparent: true
            });

            // 创建骨骼
            BONES.forEach(pair => {
                const geo = new THREE.CylinderGeometry(0.5, 0.45, 1, 12);
                geo.translate(0, 0.5, 0); geo.rotateX(Math.PI/2);
                const mesh = new THREE.Mesh(geo, mat);
                this.meshes.push({ type: 'bone', mesh: mesh, start: pair[0], end: pair[1] });
                this.group.add(mesh);
            });

            // 创建关节
            for(let i=0; i<21; i++) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
                this.meshes.push({ type: 'joint', mesh: mesh, idx: i });
                this.group.add(mesh);
            }
        }

        update(landmarks) {
            if (!landmarks) { this.group.visible = false; return; }
            this.group.visible = true;

            const worldPos = [];
            landmarks.forEach((lm, i) => {
                const x = (0.5 - lm.x) * 32;
                const y = (0.5 - lm.y) * 24;
                const z = lm.z * -25; // 深度
                worldPos.push(new THREE.Vector3(x,y,z));
            });

            this.meshes.forEach(item => {
                if (item.type === 'joint') {
                    item.mesh.position.copy(worldPos[item.idx]);
                } else {
                    const p1 = worldPos[item.start];
                    const p2 = worldPos[item.end];
                    item.mesh.position.copy(p1);
                    item.mesh.lookAt(p2);
                    item.mesh.scale.set(1, 1, p1.distanceTo(p2));
                }
            });
        }
    }

    const leftHandVisual = new RealHand();
    const rightHandVisual = new RealHand();


    // ============================================
    // 2. 核心算法：基准化特征提取 (The Baseline)
    // ============================================
    // 关键点：将绝对坐标转换为相对坐标，忽略手在屏幕的位置
    
    let savedActions = JSON.parse(localStorage.getItem('myActions') || '[]');
    let liveBuffer = [];
    const MAX_BUFFER = 50; // 实时缓存长度

    // 惯性记忆：防止丢失时归零
    let lastFeatures = Array(42).fill(0); // 21点 * 2手 * 3维 = 126? 不，我们要精简

    function extractRelativeFeatures(lLM, rLM) {
        // 如果双手都丢了，返回惯性数据
        if (!lLM && !rLM) return lastFeatures;

        const feats = [];

        // 处理单只手的函数
        const processHand = (landmarks) => {
            if (!landmarks) {
                // 如果这只手不在，填0占位
                for(let i=0; i<15*3; i++) feats.push(0);
                return;
            }

            const wrist = landmarks[0];
            // 计算尺度：手掌大小 (手腕到中指根部)
            let scale = Math.sqrt((landmarks[9].x - wrist.x)**2 + (landmarks[9].y - wrist.y)**2 + (landmarks[9].z - wrist.z)**2) || 0.1;

            // 选取关键特征点 (减少计算量，取指尖+指根)
            const indices = [4, 8, 12, 16, 20, 5, 9, 13, 17, 2, 6, 10, 14, 18]; 
            
            indices.forEach(i => {
                // 核心：所有点减去手腕坐标 (x - wrist.x)
                // 核心：除以 scale (消除距离远近影响)
                feats.push((landmarks[i].x - wrist.x) / scale);
                feats.push((landmarks[i].y - wrist.y) / scale);
                feats.push((landmarks[i].z - wrist.z) / scale);
            });
        };

        // 先左手，后右手 (或者先右后左，只要录制和识别顺序一致即可)
        // MediaPipe镜像后，Label Right 是屏幕右边的手
        processHand(lLM); 
        processHand(rLM);

        // 如果双手都在，还可以加一个双手间距特征
        if (lLM && rLM) {
            const distX = lLM[0].x - rLM[0].x;
            const distY = lLM[0].y - rLM[0].y;
            const distZ = lLM[0].z - rLM[0].z;
            feats.push(distX, distY, distZ);
        } else {
            feats.push(0, 0, 0);
        }

        lastFeatures = feats;
        return feats;
    }

    // DTW 匹配算法 (允许速度不同)
    function computeDTW(seq1, seq2) {
        const n = seq1.length;
        const m = seq2.length;
        // 长度差异太大直接跳过
        if (Math.abs(n - m) > Math.min(n, m) * 0.6) return Infinity;

        const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
        dtw[0][0] = 0;

        for (let i = 1; i <= n; i++) {
            const window = Math.max(10, Math.abs(n-m)+5);
            const start = Math.max(1, i - window);
            const end = Math.min(m, i + window);

            for (let j = start; j <= end; j++) {
                let dist = 0;
                const v1 = seq1[i-1];
                const v2 = seq2[j-1];
                // 欧氏距离
                for(let k=0; k<v1.length; k++) dist += (v1[k]-v2[k])**2;
                
                dtw[i][j] = dist + Math.min(dtw[i-1][j], dtw[i][j-1], dtw[i-1][j-1]);
            }
        }
        return dtw[n][m] / (n + m);
    }

    // 识别循环
    let cooldown = 0;
    function recognizeAction() {
        if (cooldown > 0) { cooldown--; return; }
        if (savedActions.length === 0 || liveBuffer.length < 10) return;

        let bestScore = Infinity;
        let bestName = "";

        // 遍历所有存下的动作
        savedActions.forEach(action => {
            const targetLen = action.data.length;
            // 尝试匹配不同速度 (0.8x, 1.0x, 1.2x)
            [0.8, 1.0, 1.2].forEach(speed => {
                const tryLen = Math.floor(targetLen * speed);
                if (liveBuffer.length < tryLen) return;

                const sample = liveBuffer.slice(liveBuffer.length - tryLen);
                const score = computeDTW(sample, action.data);
                
                if (score < bestScore) {
                    bestScore = score;
                    bestName = action.name;
                }
            });
        });

        // UI 更新
        document.getElementById('diff-val').textContent = bestScore.toFixed(2);
        
        // 阈值：1.5 比较宽松，适合双手复杂动作
        const THRESHOLD = 1.5; 
        const conf = Math.max(0, 1 - (bestScore/3.0)) * 100;
        document.getElementById('conf-val').textContent = Math.round(conf) + "%";
        document.getElementById('match-bar').style.width = conf + "%";

        if (bestScore < THRESHOLD) {
            triggerHologram(bestName);
            liveBuffer = []; // 清空缓存，防止重复触发
            cooldown = 40;   // 冷却时间
        }
    }


    // ============================================
    // 3. 交互逻辑 (录制、倒计时)
    // ============================================
    let isRecording = false;
    let recBuffer = [];
    const recBtn = document.getElementById('rec-btn');
    const countLayer = document.getElementById('countdown-overlay');
    const countText = document.getElementById('countdown-text');

    window.triggerRecordFlow = function() {
        if (isRecording) {
            finishRecording();
        } else {
            const name = document.getElementById('action-name').value;
            if(!name) return alert("请先输入动作名称！");
            
            // 倒计时逻辑
            countLayer.style.display = 'flex';
            let n = 3; countText.textContent = n;
            const t = setInterval(() => {
                n--;
                if(n>0) countText.textContent = n;
                else if(n===0) countText.textContent = "GO!";
                else {
                    clearInterval(t);
                    countLayer.style.display = 'none';
                    startRecording();
                }
            }, 1000);
        }
    }

    function startRecording() {
        isRecording = true;
        recBuffer = [];
        recBtn.textContent = "停止录制";
        recBtn.classList.add('recording');
        document.getElementById('sys-status').textContent = "正在录制...";
        document.getElementById('sys-status').style.color = "#ff4444";
    }

    function finishRecording() {
        isRecording = false;
        recBtn.textContent = "开始录制 (倒计时)";
        recBtn.classList.remove('recording');
        document.getElementById('sys-status').textContent = "就绪";
        document.getElementById('sys-status').style.color = "#00ffcc";

        if (recBuffer.length < 10) return alert("动作太短，无法保存");
        
        const name = document.getElementById('action-name').value;
        savedActions.push({ name: name, data: recBuffer });
        
        updateList();
        saveDB();
        triggerHologram(`已保存: ${name}`);
    }

    function updateList() {
        const box = document.getElementById('action-list');
        box.innerHTML = '';
        savedActions.forEach((item, idx) => {
            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `<span>${item.name}</span> <span class="del-icon" onclick="removeAction(${idx})">×</span>`;
            box.appendChild(div);
        });
    }

    window.removeAction = (i) => { savedActions.splice(i, 1); updateList(); saveDB(); }
    window.saveDB = () => localStorage.setItem('myActions', JSON.stringify(savedActions));
    updateList();

    let holoTimer;
    function triggerHologram(text) {
        const el = document.getElementById('hologram-display');
        el.textContent = text;
        el.classList.add('active');
        if (holoTimer) clearTimeout(holoTimer);
        holoTimer = setTimeout(() => el.classList.remove('active'), 2000);
    }


    // ============================================
    // 4. MediaPipe 集成
    // ============================================
    const videoElement = document.getElementById('input-video');

    function onResults(results) {
        let lLM = null;
        let rLM = null;
        let handStatus = "无手部";

        leftHandVisual.update(null);
        rightHandVisual.update(null);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            results.multiHandLandmarks.forEach((lm, i) => {
                const label = results.multiHandedness[i].label;
                if (label === 'Right') {
                    rightHandVisual.update(lm);
                    rLM = lm;
                } else {
                    leftHandVisual.update(lm);
                    lLM = lm;
                }
            });

            if (lLM && rLM) handStatus = "双手中";
            else if (lLM) handStatus = "左手中";
            else if (rLM) handStatus = "右手中";
        }
        document.getElementById('hand-status').textContent = handStatus;

        // 提取特征 (基准化)
        const feats = extractRelativeFeatures(lLM, rLM);

        if (isRecording) {
            recBuffer.push(feats);
        } else {
            liveBuffer.push(feats);
            if (liveBuffer.length > MAX_BUFFER) liveBuffer.shift();
            recognizeAction();
        }

        renderer.render(scene, camera);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
