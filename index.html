<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å…¨æ¯ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Orbitron:wght@900&family=Pacifico&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Roboto, sans-serif; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #1a1a2e, #000);}
        #input-video { display: none; }
        
        /* UI é¢æ¿ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 320px; max-height: 90vh;
            background: rgba(10, 15, 30, 0.9); padding: 20px; border-radius: 12px;
            border: 1px solid rgba(0, 210, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.15);
            backdrop-filter: blur(12px); z-index: 100; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: #00f2ff #111;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        #ui-layer::-webkit-scrollbar { width: 6px; }
        #ui-layer::-webkit-scrollbar-track { background: #111; }
        #ui-layer::-webkit-scrollbar-thumb { background: #00f2ff; border-radius: 3px; }
        
        h2 { margin: 0 0 10px 0; font-size: 16px; color: #00f2ff; text-transform: uppercase; letter-spacing: 2px; border-bottom: 1px solid rgba(0,242,255,0.2); padding-bottom: 10px;}
        h3 { font-size: 12px; color: #888; margin: 15px 0 5px 0; text-transform: uppercase; }

        /* è¾“å…¥æ§ä»¶é€šç”¨æ ·å¼ */
        input[type="text"], select, input[type="number"] { 
            width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #334; 
            border-radius: 4px; background: #0f1220; color: #fff; outline: none; transition: border 0.3s;
        }
        input:focus { border-color: #00f2ff; }
        
        /* é¢œè‰²é€‰æ‹©å™¨å®¹å™¨ */
        .color-picker-wrap { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 13px; color: #ccc;}
        input[type="color"] { border: none; width: 40px; height: 25px; cursor: pointer; background: none;}

        /* æ»‘å— */
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #00f2ff; }

        button {
            width: 100%; padding: 10px; border: none; border-radius: 4px; margin-top: 5px;
            background: linear-gradient(90deg, #00c6ff, #0072ff); color: white; 
            font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.02); filter: brightness(1.2); }
        button.secondary { background: #333; font-size: 10px; padding: 6px; margin-top: 10px; border: 1px solid #444;}

        /* ç›¸ä¼¼åº¦ä»ªè¡¨ç›˜ */
        .meter-container { margin-top: 15px; margin-bottom: 5px; }
        .meter-bg { width: 100%; height: 6px; background: #333; border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .meter-fill { height: 100%; width: 0%; background: #00f2ff; transition: width 0.1s linear; }

        /* åˆ—è¡¨ */
        .list-wrap { max-height: 150px; overflow-y: auto; margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 5px;}
        li { padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; font-size: 12px;}
        .del-btn { color: #ff4444; cursor: pointer; font-weight: bold; padding: 0 5px; }

        /* ä¸»æ˜¾ç¤ºæ–‡å­— */
        #main-output {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            white-space: nowrap; pointer-events: none; opacity: 0; 
            transition: opacity 0.2s, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50; 
            /* é»˜è®¤æ ·å¼ï¼Œä¼šè¢«JSè¦†ç›– */
            font-size: 100px; font-weight: 900; color: #ffffff;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #main-output.active { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    
    <div id="ui-layer">
        <h2>äº¤äº’æ§åˆ¶å°</h2>
        
        <h3>å½•åˆ¶æ–°åŠ¨ä½œ</h3>
        <input type="text" id="gesture-name" placeholder="è¾“å…¥æ˜¾ç¤ºçš„æ–‡å­—">
        <button onclick="recordGesture()">âº å½•åˆ¶å½“å‰å§¿æ€</button>
        
        <div class="meter-container">
            <div style="font-size:12px; color:#aaa; display:flex; justify-content:space-between;">
                <span>åŒ¹é…åº¦</span><span id="score-val">0%</span>
            </div>
            <div class="meter-bg"><div class="meter-fill" id="similarity-bar"></div></div>
        </div>

        <h3>æ ·å¼è‡ªå®šä¹‰</h3>
        <div class="color-picker-wrap">
            æ–‡å­—é¢œè‰²
            <input type="color" id="opt-color" value="#ffffff">
        </div>
        <div class="color-picker-wrap">
            å‘å…‰é¢œè‰²
            <input type="color" id="opt-glow" value="#00f2ff">
        </div>
        
        <div style="margin-bottom:8px; font-size:12px; color:#ccc;">
            å­—ä½“å¤§å°: <span id="size-val">100</span>px
            <input type="range" id="opt-size" min="40" max="250" value="100">
        </div>
        
        <select id="opt-font">
            <option value="'Segoe UI', sans-serif">é»˜è®¤é»‘ä½“ (Default)</option>
            <option value="'Orbitron', sans-serif">ç§‘å¹»é£æ ¼ (Sci-Fi)</option>
            <option value="'Black Ops One', cursive">å†›äº‹é£æ ¼ (Military)</option>
            <option value="'Pacifico', cursive">æ‰‹å†™é£æ ¼ (Cursive)</option>
            <option value="'Roboto Mono', monospace">ä»£ç é£æ ¼ (Mono)</option>
        </select>

        <h3 style="margin-top:20px;">æ‰‹åŠ¿åº“</h3>
        <div class="list-wrap">
            <ul id="gesture-list"></ul>
        </div>
        
        <button class="secondary" onclick="exportData()">ğŸ“‹ å¤åˆ¶å½“å‰åº“æ•°æ® (ä¾›é¢„è®¾ä½¿ç”¨)</button>
        <button class="secondary" onclick="clearStorage()" style="background:#552222;">ğŸ—‘ æ¸…ç©ºæœ¬åœ°æ•°æ®</button>
    </div>

    <div id="main-output">READY</div>
</div>

<script>
    // ==========================================
    // 1. æ•°æ®åº“ä¸æŒä¹…åŒ–é…ç½®
    // ==========================================

    // ã€å¼€å‘è€…é¢„è®¾åŒºã€‘
    // å¦‚æœä½ æƒ³ç»™æ‰€æœ‰äººé¢„è®¾æ‰‹åŠ¿ï¼Œè¯·åœ¨ç½‘é¡µä¸Šå½•åˆ¶å¥½ï¼Œç‚¹å‡»â€œå¤åˆ¶å½“å‰åº“æ•°æ®â€ï¼Œ
    // ç„¶åæŠŠå¤åˆ¶çš„ JSON ç²˜è´´æ›¿æ¢ä¸‹é¢è¿™ä¸ªç©ºæ•°ç»„ []ã€‚
    const PRESET_DB = []; 

    // è¿è¡Œæ—¶æ•°æ®
    let knownGestures = [];

    // åˆå§‹åŒ–ï¼šåŠ è½½é¢„è®¾ + æœ¬åœ°å­˜å‚¨
    function initDatabase() {
        // 1. åŠ è½½æœ¬åœ°å­˜å‚¨
        const localData = localStorage.getItem('myHandGestures');
        let localGestures = [];
        if (localData) {
            try { localGestures = JSON.parse(localData); } catch(e) { console.error(e); }
        }

        // 2. åˆå¹¶æ•°æ® (å»é‡ï¼šå¦‚æœåå­—ä¸€æ ·ï¼Œä¼˜å…ˆç”¨æœ¬åœ°çš„)
        const combined = [...localGestures];
        PRESET_DB.forEach(preset => {
            if (!combined.find(g => g.name === preset.name)) {
                combined.push(preset);
            }
        });
        
        knownGestures = combined;
        renderList();
        applyStyles(); // åº”ç”¨ä¿å­˜çš„æ ·å¼
    }

    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    function saveToStorage() {
        // æˆ‘ä»¬åªä¿å­˜ç”¨æˆ·æ–°å¢çš„ï¼Œå®é™…ä¸Šä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬ä¿å­˜å½“å‰å®Œæ•´åˆ—è¡¨
        // å®é™…å¼€å‘ä¸­å¯ä»¥åŒºåˆ†ï¼Œä½†åœ¨Demoä¸­å…¨é‡ä¿å­˜æœ€ç¨³å¦¥
        localStorage.setItem('myHandGestures', JSON.stringify(knownGestures));
    }
    
    // å¯¼å‡ºæ•°æ®åŠŸèƒ½
    window.exportData = function() {
        const dataStr = JSON.stringify(knownGestures);
        navigator.clipboard.writeText(dataStr).then(() => {
            alert("æ•°æ®å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼\n\nè¯·æ‰“å¼€ index.html ä»£ç ï¼Œæ‰¾åˆ° 'const PRESET_DB = []'ï¼Œå°†å†…å®¹ç²˜è´´è¿›å»å³å¯å®ç°é¢„è®¾ã€‚");
        });
    };

    window.clearStorage = function() {
        if(confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æœ¬åœ°æ‰‹åŠ¿å—ï¼Ÿé¢„è®¾æ‰‹åŠ¿åœ¨åˆ·æ–°åä¼šæ¢å¤ã€‚")) {
            localStorage.removeItem('myHandGestures');
            location.reload();
        }
    };

    function deleteGesture(name) {
        knownGestures = knownGestures.filter(g => g.name !== name);
        saveToStorage();
        renderList();
    }

    function renderList() {
        const ul = document.getElementById('gesture-list');
        ul.innerHTML = '';
        knownGestures.forEach(g => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${g.name} <span style="color:#666; font-size:10px;">(${g.type})</span></span>
                <span class="del-btn" onclick="deleteGesture('${g.name}')">Ã—</span>
            `;
            ul.appendChild(li);
        });
    }

    // ==========================================
    // 2. æ ·å¼è‡ªå®šä¹‰é€»è¾‘
    // ==========================================
    const mainOutput = document.getElementById('main-output');
    const inputColor = document.getElementById('opt-color');
    const inputGlow = document.getElementById('opt-glow');
    const inputSize = document.getElementById('opt-size');
    const inputFont = document.getElementById('opt-font');
    const sizeVal = document.getElementById('size-val');

    // åŠ è½½æ ·å¼è®¾ç½®
    function applyStyles() {
        const savedStyle = JSON.parse(localStorage.getItem('gestureStyle')) || {};
        if(savedStyle.color) inputColor.value = savedStyle.color;
        if(savedStyle.glow) inputGlow.value = savedStyle.glow;
        if(savedStyle.size) inputSize.value = savedStyle.size;
        if(savedStyle.font) inputFont.value = savedStyle.font;
        updateMainOutput();
    }

    function updateMainOutput() {
        const color = inputColor.value;
        const glow = inputGlow.value;
        const size = inputSize.value;
        const font = inputFont.value;

        sizeVal.textContent = size;
        
        mainOutput.style.color = color;
        mainOutput.style.fontSize = `${size}px`;
        mainOutput.style.fontFamily = font;
        // åŠ¨æ€ç”Ÿæˆé˜´å½±
        mainOutput.style.textShadow = `0 0 20px ${glow}, 0 0 40px ${glow}`;

        // ä¿å­˜æ ·å¼åå¥½
        localStorage.setItem('gestureStyle', JSON.stringify({
            color, glow, size, font
        }));
    }

    // ç»‘å®šäº‹ä»¶
    inputColor.addEventListener('input', updateMainOutput);
    inputGlow.addEventListener('input', updateMainOutput);
    inputSize.addEventListener('input', updateMainOutput);
    inputFont.addEventListener('change', updateMainOutput);


    // ==========================================
    // 3. Three.js ç²’å­ç³»ç»Ÿ (ä¿æŒåŸç‰ˆé€»è¾‘)
    // ==========================================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('container').appendChild(renderer.domElement);

    function getParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
        grad.addColorStop(0, 'rgba(200, 255, 255, 1)');
        grad.addColorStop(0.4, 'rgba(0, 180, 255, 0.5)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        return new THREE.Texture(canvas);
    }
    const particleTex = getParticleTexture();

    const BONE_CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17],[0,5]];

    class VolumetricHand {
        constructor(color = 0x00f2ff) {
            this.particleCount = 3000;
            this.geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(this.particleCount * 3);
            this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: color, size: 0.6, map: particleTex, transparent: true, opacity: 0.8,
                blending: THREE.AdditiveBlending, depthWrite: false
            });
            this.mesh = new THREE.Points(this.geometry, material);
            this.mesh.visible = false;
            scene.add(this.mesh);
            this.distribution = [];
            const particlesPerBone = Math.floor(this.particleCount / BONE_CONNECTIONS.length);
            BONE_CONNECTIONS.forEach((pair, i) => {
                let thickness = (i >= 20) ? 1.5 : (pair[1] % 4 === 0 ? 0.5 : 0.8);
                this.distribution.push({
                    startJoint: pair[0], endJoint: pair[1],
                    startIndex: i * particlesPerBone, count: particlesPerBone, thickness: thickness
                });
            });
            this.worldJoints = Array(21).fill().map(() => new THREE.Vector3());
        }

        update(landmarks) {
            if (!landmarks) { this.mesh.visible = false; return; }
            this.mesh.visible = true;
            landmarks.forEach((lm, i) => {
                const x = (0.5 - lm.x) * 30;
                const y = (0.5 - lm.y) * 25;
                const z = lm.z * -30;
                this.worldJoints[i].set(x, y, z);
            });
            const positions = this.geometry.attributes.position.array;
            this.distribution.forEach(bone => {
                const startPos = this.worldJoints[bone.startJoint];
                const endPos = this.worldJoints[bone.endJoint];
                const vec = new THREE.Vector3().subVectors(endPos, startPos);
                for (let j = 0; j < bone.count; j++) {
                    const idx = (bone.startIndex + j) * 3;
                    const t = j / bone.count;
                    positions[idx] = startPos.x + vec.x * t + (Math.random()-0.5)*bone.thickness;
                    positions[idx+1] = startPos.y + vec.y * t + (Math.random()-0.5)*bone.thickness;
                    positions[idx+2] = startPos.z + vec.z * t + (Math.random()-0.5)*bone.thickness;
                }
            });
            this.geometry.attributes.position.needsUpdate = true;
        }
    }

    const leftHandVisual = new VolumetricHand(0x00f2ff);
    const rightHandVisual = new VolumetricHand(0xff0055);
    
    // ==========================================
    // 4. æ‰‹åŠ¿è¯†åˆ«æ ¸å¿ƒ
    // ==========================================
    let currentFrameData = { left: null, right: null };
    let lastProcessTime = 0;
    const processInterval = 50;

    function getNormalizedFeatures(landmarks) {
        const wrist = landmarks[0];
        let maxDist = 0;
        landmarks.forEach(p => {
            const d = Math.sqrt((p.x-wrist.x)**2 + (p.y-wrist.y)**2 + (p.z-wrist.z)**2);
            if(d > maxDist) maxDist = d;
        });
        if(maxDist === 0) maxDist = 1;
        return landmarks.map(p => ({
            x: (p.x - wrist.x) / maxDist,
            y: (p.y - wrist.y) / maxDist,
            z: (p.z - wrist.z) / maxDist
        }));
    }

    function calculateError(l1, l2) {
        let totalError = 0;
        for (let i = 0; i < 21; i++) {
            totalError += ((l1[i].x - l2[i].x)**2 + (l1[i].y - l2[i].y)**2 + (l1[i].z - l2[i].z)**2);
        }
        return totalError;
    }

    // å½•åˆ¶å¹¶ä¿å­˜
    window.recordGesture = function() {
        const name = document.getElementById('gesture-name').value.trim();
        const hasLeft = !!currentFrameData.left;
        const hasRight = !!currentFrameData.right;
        
        if(!name) return alert("è¯·è¾“å…¥æ‰‹åŠ¿åç§°");
        if(!hasLeft && !hasRight) return alert("æœªæ£€æµ‹åˆ°æ‰‹éƒ¨");

        const newGesture = {
            name: name,
            type: (hasLeft && hasRight) ? 'double' : 'single',
            data: {}
        };

        if(hasLeft) newGesture.data.left = getNormalizedFeatures(currentFrameData.left);
        if(hasRight) newGesture.data.right = getNormalizedFeatures(currentFrameData.right);

        knownGestures.push(newGesture);
        saveToStorage(); // ä¿å­˜ï¼
        renderList();
        
        document.getElementById('gesture-name').value = '';
    };

    const scoreBar = document.getElementById('similarity-bar');
    const scoreVal = document.getElementById('score-val');
    let outputTimer = null;

    function processGestures() {
        if(knownGestures.length === 0) return;
        let bestMatch = null;
        let minError = Infinity;
        const THRESHOLD = 0.4; 

        knownGestures.forEach(gesture => {
            let currentError = 0;
            let matchCount = 0;
            let requiredCount = 0;
            
            if (gesture.data.left) { requiredCount++; if (currentFrameData.left) { currentError += calculateError(gesture.data.left, getNormalizedFeatures(currentFrameData.left)); matchCount++; } else { currentError += 10; } }
            if (gesture.data.right) { requiredCount++; if (currentFrameData.right) { currentError += calculateError(gesture.data.right, getNormalizedFeatures(currentFrameData.right)); matchCount++; } else { currentError += 10; } }

            const avgError = currentError / (requiredCount || 1);
            if (matchCount === requiredCount && avgError < minError) {
                minError = avgError;
                bestMatch = gesture.name;
            }
        });

        let confidence = 0;
        if (minError < 2.0) confidence = Math.max(0, 1 - (minError / 0.8)) * 100;
        scoreBar.style.width = `${confidence}%`;
        scoreVal.textContent = `${Math.round(confidence)}%`;
        if (minError < THRESHOLD) {
            scoreBar.style.background = "#00ff88";
            if (mainOutput.textContent !== bestMatch || !mainOutput.classList.contains('active')) {
                mainOutput.textContent = bestMatch;
                mainOutput.classList.add('active');
                if (outputTimer) clearTimeout(outputTimer);
                outputTimer = setTimeout(() => { mainOutput.classList.remove('active'); }, 1500);
            }
        } else {
            scoreBar.style.background = "#00f2ff";
        }
    }

    // MediaPipe Setup
    const videoElem = document.getElementById('input-video');
    function onResults(results) {
        currentFrameData.left = null; currentFrameData.right = null;
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            leftHandVisual.update(null); rightHandVisual.update(null);
            results.multiHandLandmarks.forEach((landmarks, index) => {
                const label = results.multiHandedness[index].label;
                if (label === 'Left') { rightHandVisual.update(landmarks); currentFrameData.right = landmarks; }
                else { leftHandVisual.update(landmarks); currentFrameData.left = landmarks; }
            });
        } else {
            leftHandVisual.update(null); rightHandVisual.update(null);
        }
        const now = Date.now();
        if (now - lastProcessTime > processInterval) { processGestures(); lastProcessTime = now; }
        renderer.render(scene, camera);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);
    new Camera(videoElem, { onFrame: async () => { await hands.send({image: videoElem}); }, width: 1280, height: 720 }).start();
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    // å¯åŠ¨åˆå§‹åŒ–
    initDatabase();

</script>
</body>
</html>
