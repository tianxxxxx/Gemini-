<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI 智能手势训练系统</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier"></script>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Noto Sans SC', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); z-index: 0;
        }

        /* 左侧 AI 控制台 */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 320px;
            background: rgba(16, 20, 24, 0.85);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-left: 4px solid #00ffc8;
            border-radius: 12px; padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            color: #fff; z-index: 100;
        }

        h2 { margin: 0 0 15px 0; font-family: 'Orbitron', sans-serif; color: #00ffc8; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;}
        
        .info-row { display: flex; justify-content: space-between; font-size: 12px; color: #aaa; margin-bottom: 15px; }
        .highlight { color: #fff; font-weight: bold; }

        /* 训练控制区 */
        .train-section { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        
        input { 
            width: 100%; padding: 10px; margin-bottom: 10px; 
            border: 1px solid #334; border-radius: 4px;
            background: #0b0e11; color: #00ffc8; outline: none; box-sizing: border-box; font-weight: bold;
        }
        
        /* 训练按钮 */
        button#train-btn {
            width: 100%; padding: 15px; border: none; border-radius: 4px;
            background: linear-gradient(90deg, #00b894, #00cec9); color: #000; 
            font-weight: 900; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.1s;
        }
        button#train-btn:active { transform: scale(0.95); background: #fff; }
        button#train-btn.training { background: #ff7675; color: white; animation: pulse 0.5s infinite; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        /* 样本列表 */
        .class-list { max-height: 150px; overflow-y: auto; margin-top: 10px; }
        .class-item { 
            display: flex; justify-content: space-between; padding: 8px; 
            background: rgba(0,0,0,0.3); margin-bottom: 5px; border-radius: 4px; font-size: 12px;
            border-left: 2px solid #555; align-items: center;
        }
        .class-item.active { border-left: 2px solid #00ffc8; background: rgba(0, 255, 200, 0.1); }
        .sample-count { background: #333; padding: 2px 6px; border-radius: 10px; color: #fff; font-size: 10px; }

        /* 预测结果展示 */
        .prediction-box { margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 6px; text-align: center; }
        .pred-label { font-size: 24px; font-weight: bold; color: #00ffc8; text-shadow: 0 0 10px rgba(0,255,200,0.5); min-height: 36px;}
        .pred-conf { font-size: 12px; color: #888; height: 16px;}

        /* 全息文字 */
        #hologram {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-size: 80px; font-weight: 900; 
            color: rgba(255,255,255,0.9); text-shadow: 0 0 30px #00ffc8;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 200;
        }
        #hologram.show { opacity: 1; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    
    <div id="ui-layer">
        <h2>AI 神经训练核心</h2>
        <div class="info-row">
            <span>引擎: <span class="highlight">TensorFlow.js</span></span>
            <span>状态: <span id="tf-status" style="color:#aaa">加载中...</span></span>
        </div>

        <div class="train-section">
            <div style="font-size:12px; color:#bbb; margin-bottom:5px;">第一步: 输入动作名称</div>
            <input type="text" id="class-name" placeholder="例如: 竖大拇指">
            
            <div style="font-size:12px; color:#bbb; margin-bottom:5px;">第二步: 按住按钮喂数据</div>
            <button id="train-btn" onmousedown="startTraining()" onmouseup="stopTraining()" ontouchstart="startTraining()" ontouchend="stopTraining()">
                按住采集样本
            </button>
        </div>

        <div style="font-size:12px; color:#888;">已训练的分类 (样本数):</div>
        <div class="class-list" id="class-list">
            </div>

        <div class="prediction-box">
            <div style="font-size:10px; color:#666;">AI 实时推理结果</div>
            <div class="pred-label" id="result-label">--</div>
            <div class="pred-conf" id="result-conf">置信度: 0%</div>
        </div>

        <button onclick="clearAI()" style="width:100%; margin-top:10px; padding:8px; background:#333; border:none; color:#888; font-size:10px; cursor:pointer;">重置 AI 模型</button>
    </div>

    <div id="hologram">AI READY</div>
</div>

<script>
    // ============================================
    // 1. TensorFlow.js AI 逻辑 (KNN Classifier)
    // ============================================
    let classifier = null;
    let isTraining = false;
    let trainingLabel = "";
    
    // 存储每个类别的样本数，用于UI显示
    let classCounts = {}; 

    async function initTF() {
        // 创建 KNN 分类器
        classifier = knnClassifier.create();
        document.getElementById('tf-status').textContent = "就绪";
        document.getElementById('tf-status').style.color = "#00ffc8";
    }
    initTF();

    // 添加样本到 AI
    function addExample(features) {
        if (!classifier || !isTraining) return;
        
        // 将特征数组转换为 Tensor
        const tensor = tf.tensor(features);
        
        // 喂给分类器
        classifier.addExample(tensor, trainingLabel);
        
        // 更新计数
        if (!classCounts[trainingLabel]) classCounts[trainingLabel] = 0;
        classCounts[trainingLabel]++;
        
        updateClassListUI();
        
        // 内存清理 (虽然 TFJS 会管理，但手动 dispose input tensor 是好习惯)
        tensor.dispose();
    }

    // 预测
    async function predict(features) {
        if (!classifier || classifier.getNumClasses() === 0) return;
        
        const tensor = tf.tensor(features);
        
        try {
            // k=3 表示参考最近的3个样本来投票
            const result = await classifier.predictClass(tensor, 30); // k值增大增加稳定性
            
            const label = result.label;
            const probability = result.confidences[label];
            
            // 更新 UI
            const labelEl = document.getElementById('result-label');
            const confEl = document.getElementById('result-conf');
            
            labelEl.textContent = label;
            confEl.textContent = `置信度: ${Math.floor(probability * 100)}%`;

            // 高亮列表
            document.querySelectorAll('.class-item').forEach(el => el.classList.remove('active'));
            const activeItem = document.getElementById(`item-${label}`);
            if (activeItem) activeItem.classList.add('active');

            // 全息显示 (置信度 > 80% 才显示)
            const holo = document.getElementById('hologram');
            if (probability > 0.8) {
                holo.textContent = label;
                holo.classList.add('show');
            } else {
                holo.classList.remove('show');
            }

        } catch (e) {
            console.error(e);
        } finally {
            tensor.dispose();
        }
    }

    // UI 控制
    const trainBtn = document.getElementById('train-btn');
    const nameInput = document.getElementById('class-name');

    window.startTraining = function() {
        const name = nameInput.value.trim();
        if (!name) { alert("请先输入动作名称！"); return; }
        trainingLabel = name;
        isTraining = true;
        trainBtn.textContent = "正在学习...";
        trainBtn.classList.add('training');
    };

    window.stopTraining = function() {
        isTraining = false;
        trainBtn.textContent = "按住采集样本";
        trainBtn.classList.remove('training');
    };

    window.clearAI = function() {
        if(confirm("确定要删除所有训练数据吗？")) {
            classifier.clearAllClasses();
            classCounts = {};
            updateClassListUI();
            document.getElementById('result-label').textContent = "--";
        }
    }

    function updateClassListUI() {
        const list = document.getElementById('class-list');
        list.innerHTML = "";
        for (let [name, count] of Object.entries(classCounts)) {
            const div = document.createElement('div');
            div.className = 'class-item';
            div.id = `item-${name}`;
            div.innerHTML = `<span>${name}</span> <span class="sample-count">${count} 样本</span>`;
            list.appendChild(div);
        }
    }


    // ============================================
    // 2. Three.js 视觉 (拟真手 + 识别点)
    // ============================================
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0);
    document.getElementById('container').appendChild(renderer.domElement);

    // 灯光
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const pointLight = new THREE.PointLight(0x00ffc8, 0.8);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    const BONES = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17],[0,5]];

    class CyberHand {
        constructor() {
            this.group = new THREE.Group();
            scene.add(this.group);
            
            this.segments = [];
            this.trackers = []; // 识别点

            // 1. 皮肤材质 (拟人)
            const skinMat = new THREE.MeshPhysicalMaterial({
                color: 0xffdbac, roughness: 0.3, metalness: 0.1, 
                transparent: true, opacity: 0.9
            });

            // 2. 识别点材质 (高亮青色能量球)
            const trackerMat = new THREE.MeshBasicMaterial({ color: 0x00ffc8 });

            // 构建骨骼蒙皮
            BONES.forEach(pair => {
                const geo = new THREE.CylinderGeometry(0.5, 0.45, 1, 16);
                geo.translate(0, 0.5, 0); geo.rotateX(Math.PI/2);
                const mesh = new THREE.Mesh(geo, skinMat);
                this.segments.push({ mesh: mesh, start: pair[0], end: pair[1] });
                this.group.add(mesh);
            });

            // 构建识别点 (Tracker Points)
            for(let i=0; i<21; i++) {
                // 关节处用稍微大一点的球作为皮肤连接
                const jointGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const jointMesh = new THREE.Mesh(jointGeo, skinMat);
                this.group.add(jointMesh);

                // 在关节中心叠加一个显眼的小亮点，代表AI捕捉点
                const trackerGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const trackerMesh = new THREE.Mesh(trackerGeo, trackerMat);
                trackerMesh.visible = true; // 默认可见
                this.trackers.push({ joint: jointMesh, marker: trackerMesh });
                this.group.add(trackerMesh);
            }
        }

        update(landmarks) {
            if (!landmarks) { this.group.visible = false; return; }
            this.group.visible = true;
            
            const worldPos = [];
            landmarks.forEach((lm, i) => {
                const x = (0.5 - lm.x) * 32; 
                const y = (0.5 - lm.y) * 24; 
                const z = lm.z * -25;
                const v = new THREE.Vector3(x, y, z);
                worldPos.push(v);

                // 更新皮肤关节位置
                this.trackers[i].joint.position.copy(v);
                // 更新识别点位置 (为了好看，让它稍微浮在表面一点，或者就在中心发光)
                this.trackers[i].marker.position.copy(v);
            });

            // 更新骨骼连线
            this.segments.forEach(seg => {
                const p1 = worldPos[seg.start];
                const p2 = worldPos[seg.end];
                seg.mesh.position.copy(p1);
                seg.mesh.lookAt(p2);
                seg.mesh.scale.set(1, 1, p1.distanceTo(p2));
            });
        }
    }

    const leftHand = new CyberHand();
    const rightHand = new CyberHand();

    // ============================================
    // 3. 特征提取 (Flat Data for AI)
    // ============================================
    
    // 我们将双手的所有坐标压平成一个一维数组 [x1,y1,z1, x2,y2,z2 ...]
    // 2只手 * 21点 * 3维 = 126个数值
    // 如果某只手缺失，填0
    function extractAIFeatures(lLandmarks, rLandmarks) {
        let features = [];

        const processHand = (lm) => {
            if (!lm) {
                // 如果手丢了，填63个0
                for(let i=0; i<21*3; i++) features.push(0);
                return;
            }
            const wrist = lm[0];
            // 简单的归一化: 减去手腕坐标，使手势位置独立
            lm.forEach(p => {
                features.push(p.x - wrist.x);
                features.push(p.y - wrist.y);
                features.push(p.z - wrist.z); // Z在近距离交互中对某些动作很重要
            });
        };

        processHand(lLandmarks);
        processHand(rLandmarks);

        return features;
    }


    // ============================================
    // 4. MediaPipe Loop
    // ============================================
    const videoElem = document.getElementById('input-video');

    function onResults(results) {
        let lLM = null; 
        let rLM = null;
        
        leftHand.update(null);
        rightHand.update(null);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            results.multiHandLandmarks.forEach((lm, i) => {
                const label = results.multiHandedness[i].label;
                if (label === 'Right') {
                    rightHand.update(lm);
                    rLM = lm;
                } else {
                    leftHand.update(lm);
                    lLM = lm;
                }
            });
        }

        // 提取特征
        const features = extractAIFeatures(lLM, rLM);

        // 如果正在按按钮，喂数据给 AI
        if (isTraining) {
            addExample(features);
        } else if (classifier && classifier.getNumClasses() > 0) {
            // 如果不在训练，且模型里有数据，就预测
            predict(features);
        }

        renderer.render(scene, camera);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElem, {
        onFrame: async () => { await hands.send({image: videoElem}); },
        width: 1280, height: 720
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
